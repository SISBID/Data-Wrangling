---
title: "Data Cleaning Part 1"
author: "Data Wrangling in R"
output:
  ioslides_presentation:
    css: styles.css
    widescreen: yes
---


```{r, include = FALSE}
library(knitr)
library(tidyverse)
library(janitor)
opts_chunk$set(comment = "")
```

## Data Cleaning

In general, data cleaning is a process of investigating your data for inaccuracies, or recoding it in a way that makes it more manageable.

MOST IMPORTANT RULE - LOOK AT YOUR DATA!



## Read in the UFO dataset

Read in data or download from: http://sisbid.github.io/Data-Wrangling/data/ufo/ufo_data_complete.csv.gz

```{r}
ufo <- read_delim("../data/ufo/ufo_data_complete.txt")

```

## The "problems"
You saw warning messages when reading in this dataset. We can see these with the `problems()` function from `readr`. 

```{r}
p <-problems(ufo)
p
```

## The "problems"
These all became NA values.

```{r}
ufo[(p$row-1),] %>% glimpse()
```

## The "problems"


```{r, echo = FALSE}
knitr::include_graphics(here::here("lecture_notes", "media", "problems.png"))

```

<!-- ## Data cleaning "before" R -->

<!-- You saw warning messages when reading in this dataset. We can see these with the `problems()` function from `readr`.  -->

<!-- ```{r} -->
<!-- p = problems(ufo) -->
<!-- p -->
<!-- ``` -->

## Reading in again

Now we have a chance to keep but clean these values!

```{r}
ufo <- read_delim("../data/ufo/ufo_data_complete.txt", 
                  col_types = cols("duration (seconds)" = col_character()))

ufo %>% glimpse()

```

## Clean names with the `clean_names()` function from the `janitor` package

```{r}
colnames(ufo)
ufo = clean_names(ufo)
colnames(ufo)
```

<!-- ## Let's just drop those problematic rows for now. -->

<!-- Though you would usually want to check them! -->



# Recoding Variables

## Creating conditional variables

One frequently-used tool is creating variables with conditions.

A general function for creating new variables based on existing variables is the `ifelse()` function, which "returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is `TRUE` or `FALSE`."

```
ifelse(test, yes, no)

# test: an object which can be coerced
    to logical mode.
# yes: return values for true elements of test.
# no: return values for false elements of test.
```

## Recoding to missing

Sometimes people code missing data in weird or inconsistent ways.

```{r codeNA}
ages <-  data.frame(age = c(23,-999,21,44,32,57,65,54))
range(ages$age)
```


## Recoding to create new column
Say we want to make a new column about if the age was over 30?

```{r}
pull(ages, age)
ages <- ages %>% mutate(over_20 = ifelse(age > 30, "Yes", "No"))
ages
```



## Recoding value to missing

How do we change the `-999` to be treated as missing for the age column?

```{r codeNA2}
pull(ages, age)
ages <- ages %>% mutate(age = ifelse(age == -999, NA, age))
range(ages$age)
range(ages$age, na.rm=TRUE)
pull(ages, age)
```

<!-- ## Recoding from missing -->

<!-- What if you were the person that coded the `-999` -->

<!-- ```{r codeFromNA} -->
<!-- ages = ages %>% mutate(age = ifelse(is.na(age), -999, age)) -->
<!-- ages -->
<!-- ``` -->

## Adding columns to a `data.frame`: dplyr

```{r}
ufo <- ufo %>% mutate( 
              region = ifelse(
              country %in% c("us", "ca"),
              "North America",
              "Not North America")
            )
ufo %>% select(country, region) %>% head()
```

## `case_when` provides a more general way

```
casewhen(test ~ value if test is true,
         test2 ~ vlue if test2 is true,
         TRUE ~ value if all above tests are not true) # defaults to NA
```
```{r}
ufo <- ufo %>% mutate( 
            region = case_when(
              country %in% c("us", "ca") ~ "North America",
              country %in% c("de") ~ "Europe",
              country %in% "gb" ~ "Great Britain",
            ))

ufo %>% select(country, region) %>% head()
```
## `case_when` defaults to NA when all tests fail

```{r}
ufo <- ufo %>% mutate( 
            region = case_when(
              country %in% c("us", "ca") ~ "North America",
              country %in% c("de") ~ "Europe"
              #country %in% "gb" ~ "Great Britain",
            ))

ufo %>% select(country, region) %>% head()
```


## `case_when()` with value if all tests fail

```{r}
ufo <- ufo %>% mutate( 
            region = case_when(
              country %in% c("us", "ca") ~ "North America",
              country %in% c("de") ~ "Europe",
              country %in% "gb" ~ "Great Britain",
              TRUE ~ "Other"
            ))
ufo %>% select(country, region) %>% head()
```




## `case_when()` with value if all tests fail (use a variable!)

```{r}
ufo <- ufo %>% mutate( 
            region = case_when(
              country %in% "gb" ~ "Great Brit.",
              TRUE ~ region
            ))
ufo %>% select(country, region) %>% head()
```



## Example of Cleaning: more complicated

For example, let's say gender was coded as Male, M, m, Female, F, f.  Using Excel to find all of these would be a matter of filtering and changing all by hand or using if statements.

Sometimes though, it's not so simple.  That's where functions that find patterns come to be very useful.

```{r gender, echo=FALSE}
set.seed(4) # random sample below - make sure same every time
gender <- sample(c("Male", "mAle", "MaLe", "M", "MALE", "Ma", "FeMAle", "F", "Woman", "Man", "Fm", "FEMALE"), 1000, replace = TRUE)
data_gen = tibble(gender)
```

```{r gentab}
table(gender)
```

## Example of Cleaning: more complicated
In R, you could use `case_when()`:

```{r}
#case_when way:
data_gen <-data_gen %>% mutate(gender = 
                      case_when(gender %in% c("Male", "M", "m", "Man")
                                ~ "Male",
                           TRUE ~ gender)) 
head(data_gen)
```

Oh dear! This only fixes some values! It is difficult to notice values like `"MaLe"`.

# String functions

## The `stringr` package

Like `dplyr`, the `stringr` package:

* Makes some things more intuitive
* Is different than base R
* Is used on forums for answers
* Has a standard format for most functions: `str_`
    * the first argument is a string like first argument is a `data.frame` in `dplyr`


## Useful String Functions

Useful String functions from base R and `stringr`

* `toupper()`, `tolower()` - uppercase or lowercase your data
* `str_sentence()`  - uppercase just the first character (in the `stringr` package)

* `paste()` - paste strings together with a space 
* `paste0` - paste strings together with no space as default

* `str_trim()` (in the `stringr` package) or `trimws` in base 
    - will trim whitespace
* `nchar` - get the number of characters in a string

## recoding with `str_to_sentence()`

```{r}
#case_when way:
data_gen <-data_gen %>%
                mutate(gender = str_to_sentence(gender)) %>%
                mutate(gender = 
                      case_when(gender %in% c("Male", "M", "m", "Man")
                                ~ "Male",
                           TRUE ~ gender)) 
head(data_gen)
```
OK, now we are getting somewhere!


